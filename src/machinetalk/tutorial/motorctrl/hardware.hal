
newthread base-thread 300000 

loadrt hal_bb_gpio output_pins=807,809,811,813,815,817 input_pins=808,810,812,814,816
loadrt [PRUCONF](DRIVER) prucode=[HAL](HAL_RTMOD_DIR)/[PRUCONF](PRUBIN) [PRUCONF](CONFIG) halname=hpg
loadrt hal_arm335xQEP encoders=eQEP0

loadrt pwmgen output_type=2
loadrt not

# ################################################
# STEPPER (1)
# ################################################

# timing parameters
setp hpg.stepgen.00.dirsetup        [STEPPER]DIRSETUP
setp hpg.stepgen.00.dirhold         [STEPPER]DIRHOLD

setp hpg.stepgen.00.steplen         [STEPPER]STEPLEN
setp hpg.stepgen.00.stepspace       [STEPPER]STEPSPACE

setp hpg.stepgen.00.position-scale  [STEPPER]SCALE

setp hpg.stepgen.00.maxvel          [STEPPER]STEPGEN_MAX_VEL
setp hpg.stepgen.00.maxaccel        [STEPPER]STEPGEN_MAX_ACC

#setp hpg.stepgen.00.step_type       0
setp hpg.stepgen.00.steppin        923
setp hpg.stepgen.00.dirpin         924



# ################################################
# PWMGENS (2)
# ################################################

# setp hpg.pwmgen.00.pwm_period       200000
#setp hpg.pwmgen.00.out.00.value 0.1

# Bed Heater FET 1
# setp hpg.pwmgen.00.out.00.pin       817  # L_EN, R_EN - green
# setp hpg.pwmgen.00.out.00.enable    1
# setp hpg.pwmgen.00.out.00.value     0.0


# ################################################
# soft PWMGENS (1)
# ################################################
setp pwmgen.0.scale  1.0
setp pwmgen.0.offset 0.0

setp pwmgen.0.pwm-freq 300

#setp pwmgen.0.enable 1

# ################################################
# encoder (eQEP0, 1)
# ################################################

# wirings
net led  bb_gpio.p8.out-07

# motor direction
net lpwm  bb_gpio.p8.out-09  pwmgen.0.up
net rpwm  bb_gpio.p8.out-11  pwmgen.0.down

# motor enable 
net led bb_gpio.p8.out-17 pwmgen.0.enable



# motor PWM





# Thanks for the great info!! I thought I would share how I controlled this with one PWM pin. I “drove” both the enables with one PWM pin (Pin 44 goes to R_EN and L_EN). I then used the LPWM and RPWM pins to set the direction. I also use some digital pins to power/ground the logic of the IBT-2’s (46,47,52, 53).

# The following code is for the Mega-2560 and can control two IBT-2’s

# int pwmpin1=44; // 8-bit pwm 0-255 timer 5 for motor 1
# int pwmpin2=45; // 8-bit pwm 0-255 for motor 2
# int mcgnd1=46; // ground for motor control 1
# int mcpwr1=47; // power for motor control 1
# int pwmdirection2r=48; // digital motor control direction 2
# int pwmdirection2l=49; // digital motor control direction 2
# int pwmdirection1r=50; // digital motor control direction 1
# int pwmdirection1l=51; // digital motor control direction 1
# int mcgnd2=52; // ground for motor control 2
# int mcpwr2=53; // power for motor control 2

# //Code snippet for two motors on 2 IBT-2’s using just two pwm pins.

# //set h-bridge to reverse or CCW
# digitalWrite(pwmdirection1r,HIGH);
# digitalWrite(pwmdirection1l,LOW);
# analogWrite(pwmpin1,128);

# delay(5000);

# //else CW
# digitalWrite(pwmdirection1r,LOW);
# digitalWrite(pwmdirection1l,HIGH);
# analogWrite(pwmpin1,128);

# delay(5000);
# //set h-bridge to reverse or CCW motor 2
# digitalWrite(pwmdirection2r,HIGH);
# digitalWrite(pwmdirection2l,LOW);
# analogWrite(pwmpin2,128);

# delay(5000);

# //else CW
# digitalWrite(pwmdirection2r,LOW);
# digitalWrite(pwmdirection2l,HIGH);
# analogWrite(pwmpin2,128);